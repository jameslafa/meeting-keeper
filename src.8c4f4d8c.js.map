{"version":3,"sources":["tick-event.ts","timer.ts","helper.ts","human-readable-duration.ts","meeting-step.ts","meeting.ts","index.ts"],"names":[],"mappings":"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","file":"src.8c4f4d8c.js","sourceRoot":"../src","sourcesContent":["import { HumanReadableDuration } from './human-readable-duration';\n\nexport class TickEvent {\n  time: HumanReadableDuration;\n\n  constructor(hours: number, minutes: number, seconds: number) {\n    this.time = { hours, minutes, seconds };\n  }\n\n  isExpired(): boolean {\n    return this.time.hours === 0 && this.time.minutes === 0 && this.time.seconds === 0;\n  }\n}\n","import { TickEvent } from './tick-event';\n\nexport type tickListener = (t: TickEvent) => void;\nexport class Timer {\n  private remainingSeconds: number;\n  private running: boolean;\n  private timer?: number; // timer for the ticker\n\n  // listeners\n  private onTicklisteners: Set<tickListener>;\n\n  constructor(seconds: number) {\n    this.remainingSeconds = seconds;\n    this.running = false;\n    this.onTicklisteners = new Set();\n  }\n\n  onTick(f: tickListener) {\n    this.onTicklisteners.add(f);\n  }\n\n  offTick(f: tickListener): void {\n    this.onTicklisteners.delete(f);\n  }\n\n  resume() {\n    if (this.running) {\n      return;\n    }\n\n    this.running = true;\n\n    const tick = () => {\n      const now = Date.now();\n      if (this.onTicklisteners.size > 0) {\n        const hours = Math.floor(this.remainingSeconds / (60 * 60));\n        const minutes = Math.floor((this.remainingSeconds % (60 * 60)) / 60);\n        const seconds = Math.floor(this.remainingSeconds % 60);\n        this.onTicklisteners.forEach((listener) => listener(new TickEvent(hours, minutes, seconds)));\n      }\n      if (this.remainingSeconds < 1) {\n        this.pause();\n      } else {\n        this.remainingSeconds -= 1;\n        this.timer = setTimeout(tick, now + 1000 - Date.now());\n      }\n    };\n\n    tick();\n  }\n\n  pause() {\n    if (!this.running) {\n      return;\n    }\n\n    this.running = false;\n    if (this.timer) {\n      clearTimeout(this.timer);\n      delete this.timer;\n    }\n  }\n\n  isRunning?() {\n    return this.running;\n  }\n}\n","// randomID generates a random string which can be used as\n// an ID. There are risk of collision, this is NOT a UUID.\n// However, to generate a few element in a page, it's a pragmatic\n// choice to avoid a dependency toward a UUID lib.\nexport function randomID(): string {\n  return Math.random().toString(36).substr(2, 12);\n}\n","// HumanReadableDuration represents a duration in something most humans would\n// prefer to read (hours, minutes and seconds).\nexport interface HumanReadableDuration {\n  hours: number;\n  minutes: number;\n  seconds: number;\n}\n\n// secondsToHumanReadableDuration converts a number of second to a HumanReadableDuration.\nexport function secondsToHumanReadableDuration(s: number): HumanReadableDuration {\n  const hours = Math.floor(s / (60 * 60));\n  const minutes = Math.floor((s % (60 * 60)) / 60);\n  const seconds = Math.floor(s % 60);\n  return { hours, minutes, seconds };\n}\n\n// humanReadableDurationToString converts a HumanReadableDuration to a string XXhXXmXXs\nexport function humanReadableDurationToString(h: HumanReadableDuration) {\n  const s = [];\n  if (h.hours > 0) {\n    s.push(h.hours.toString() + 'h');\n  }\n  if (h.hours > 0 || h.minutes > 0) {\n    s.push(h.minutes.toString() + 'm');\n  }\n  s.push(h.seconds.toString() + 's');\n  return s.join('');\n}\n","import { Timer } from './timer';\nimport { randomID } from './helper';\nimport { HumanReadableDuration, secondsToHumanReadableDuration } from './human-readable-duration';\n\nexport class MeetingStep {\n  id: string;\n  name: string;\n  timeInSeconds: number;\n  private stepTimer: Timer;\n\n  // create a new MeetingStep. If `id` is immited, we generate a random one.\n  constructor(name: string, timeInSeconds: number, id?: string) {\n    this.name = name;\n    this.timeInSeconds = timeInSeconds;\n    this.stepTimer = new Timer(timeInSeconds);\n    this.id = id !== undefined ? id : randomID();\n  }\n\n  timer(): Timer {\n    return this.stepTimer;\n  }\n\n  humanReadableDuration(): HumanReadableDuration {\n    return secondsToHumanReadableDuration(this.timeInSeconds);\n  }\n}\n","import { MeetingStep } from './meeting-step';\nimport { tickListener } from './timer';\nimport { HumanReadableDuration, secondsToHumanReadableDuration } from './human-readable-duration';\n\nexport type stepChangeListener = () => void;\n\nexport class Meeting {\n  private _steps: MeetingStep[];\n  private _currentStepIdx: number;\n  private _startedAt?: Date;\n  private _finishedAt?: Date;\n\n  private onTicklisteners: Set<tickListener>;\n  private onStepChangeListeners: Set<stepChangeListener>;\n\n  constructor(steps: MeetingStep[]) {\n    this._steps = steps;\n    this._currentStepIdx = 0;\n    this.onTicklisteners = new Set();\n    this.onStepChangeListeners = new Set();\n  }\n\n  // addStep adds a new step to the meeting.\n  addStep(s: MeetingStep) {\n    this._steps.push(s);\n    this._currentStepIdx = 0;\n  }\n\n  // steps returns an array of all steps.\n  steps(): MeetingStep[] {\n    return this._steps;\n  }\n\n  // currentStep returns the current step.\n  currentStep(): MeetingStep {\n    return this._steps[this._currentStepIdx];\n  }\n\n  // startMeeting starts the meeting and the first step timer.\n  startMeeting() {\n    this._startedAt = new Date();\n    this.startCurrentTimer();\n  }\n\n  // hasStarted returns true if the meeting has already started.\n  hasStarted() {\n    return this._startedAt !== undefined;\n  }\n\n  // stopMeeting stops the meeting.\n  stopMeeting() {\n    this._finishedAt = new Date();\n  }\n\n  // startCurrentTimer binds onTick events and resume the current step.\n  // should be called when steps is started for the first time or after a change of step.\n  startCurrentTimer() {\n    this.onTicklisteners.forEach((l) => this.currentStep().timer().onTick(l));\n    this.currentStep().timer().resume();\n  }\n\n  // stopCurrentTimer unbinds onTick events and pause the current step.\n  // should be called when steps is stopped before a change of step.\n  stopCurrentTimer() {\n    this.onTicklisteners.forEach((l) => this.currentStep().timer().offTick(l));\n    this.currentStep().timer().pause();\n  }\n\n  // resumeCurrentTimer resumes the current step timer after it has been paused.\n  resumeCurrentTimer() {\n    this.currentStep().timer().resume();\n  }\n\n  // pauseCurrentTimer pauses the current step timer.\n  pauseCurrentTimer() {\n    this.currentStep().timer().pause();\n  }\n\n  // nextStep jumps to the next step if available.\n  nextStep() {\n    if (this._currentStepIdx < this._steps.length - 1) {\n      this.startStep(this._currentStepIdx + 1);\n    }\n  }\n\n  // jumpToStep jumps to a specific steps identified by its id.\n  jumpToStep(id: string) {\n    const stepIdx = this._steps.findIndex((s) => s.id === id);\n    if (stepIdx !== undefined) {\n      this.startStep(stepIdx);\n    }\n  }\n\n  // startStep starts a new step and make sure the previous one is stopped.\n  startStep(stepIdx: number) {\n    this.stopCurrentTimer();\n    this._currentStepIdx = stepIdx;\n    this.startCurrentTimer();\n    this.onStepChangeListeners.forEach((l) => l());\n  }\n\n  // totalDuration returns a HumanReadableDuration of the duration of the entire meeting.\n  totalDuration(): HumanReadableDuration {\n    return secondsToHumanReadableDuration(this._steps.reduce((acc, step) => acc + step.timeInSeconds, 0));\n  }\n\n  // onTick register a new tickListener.\n  onTick(f: tickListener) {\n    this.onTicklisteners.add(f);\n  }\n\n  // onStepChange register a new stepChangeListener.\n  onStepChange(f: stepChangeListener) {\n    this.onStepChangeListeners.add(f);\n  }\n}\n","import { MeetingStep } from './meeting-step';\nimport { Meeting } from './meeting';\nimport { humanReadableDurationToString, HumanReadableDuration } from './human-readable-duration';\n\n// updateTimer updates the timer values on the page.\n// lastTickEvent is used to update only elements which have changed.\nfunction updateTimer(newTime: HumanReadableDuration, lastTime: HumanReadableDuration) {\n  const pad = (n: number): string => {\n    return String(n).padStart(2, '0');\n  };\n  if (newTime.hours !== lastTime.hours) {\n    document.getElementById('hours')!.innerText = pad(newTime.hours);\n  }\n  if (newTime.minutes !== lastTime.minutes) {\n    document.getElementById('minutes')!.innerText = pad(newTime.minutes);\n  }\n  if (newTime.seconds !== lastTime.seconds) {\n    document.getElementById('seconds')!.innerText = pad(newTime.seconds);\n  }\n}\n\n// updateSteps update the list of steps displayed on the page.\nfunction updateSteps(meeting: Meeting) {\n  const domElements = [];\n  for (let i = 0; i < meeting.steps().length; i++) {\n    const step = meeting.steps()[i];\n    const elemClass = step.id === meeting.currentStep().id ? 'step active' : 'step';\n    domElements[i] = `<div class=\"${elemClass}\" id=\"${step.id}\">${\n      step.name\n    } <span class=\"duration\">${humanReadableDurationToString(step.humanReadableDuration())}</span></div>`;\n  }\n  document.getElementById('steps')!.innerHTML = domElements.join('\\n');\n\n  for (const step of meeting.steps()) {\n    const btnElt = document.getElementById(step.id);\n    if (btnElt) {\n      btnElt.addEventListener('click', () => {\n        jumpToStep(meeting, step.id);\n        return false;\n      });\n    }\n  }\n}\n\n// jumpToStep jump to the step identified by stepId.\nfunction jumpToStep(meeting: Meeting, stepId: string) {\n  meeting.jumpToStep(stepId);\n}\n\n// setupControls binds controls click event.\nfunction setupControls(meeting: Meeting) {\n  const resumeElt = document.getElementById('resume');\n  if (resumeElt) {\n    resumeElt.addEventListener('click', () => {\n      if (!meeting.hasStarted()) {\n        resumeElt.innerText = 'RESUME';\n        meeting.startMeeting();\n      } else {\n        meeting.resumeCurrentTimer();\n      }\n    });\n  }\n\n  const pauseElt = document.getElementById('pause');\n  if (pauseElt) {\n    pauseElt.addEventListener('click', () => meeting.pauseCurrentTimer());\n  }\n}\n\nwindow.onload = () => {\n  // create the meeting with the respective steps\n  // TODO: load this from a JSON instead of hardcoding values\n  const steps: MeetingStep[] = [];\n  steps.push(new MeetingStep('Introduction', 90));\n  steps.push(new MeetingStep('Product comprehension', 20));\n  const meeting = new Meeting(steps);\n\n  let lastTimeDuration = { hours: 0, minutes: 0, seconds: 0 };\n  // keep the last tickEvent to update only changed values\n  updateTimer(meeting.currentStep().humanReadableDuration(), lastTimeDuration);\n\n  // display the current steps\n  updateSteps(meeting);\n\n  // setup control buttons\n  setupControls(meeting);\n\n  // subcribe to tick event to update timer values\n  meeting.onTick((t): void => {\n    console.debug('new tick', t);\n    updateTimer(t.time, lastTimeDuration);\n    if (t.isExpired()) {\n      setTimeout(() => meeting.nextStep(), 1000);\n    }\n    lastTimeDuration = t.time;\n  });\n\n  // subscribe to step changes to update the step list\n  meeting.onStepChange(() => {\n    console.debug('step changed');\n    updateSteps(meeting);\n  });\n};\n"]}